
# 3. Explain the Primary Key and Foreign Key concepts in PostgreSQL.

**প্রাইমারি কী (Primary Key):**  
এটি এমন একটি কলাম বা একাধিক কলামের সংমিশ্রণ, যা একটি টেবিলের প্রতিটি রো/ডেটাকে ইউনিকভাবে চিহ্নিত করে। এই কী-এর মান কখনোই ফাঁকা বা ডুপ্লিকেট হতে পারে না।


**বৈশিষ্ট্যগুলি:**

- একটি টেবিলের প্রতিটি রেকর্ডকে ইউনিকভাবে আইডেন্টিফাই করে  
- সাধারণত টেবিলের ডিফল্ট ইনডেক্স হিসেবে কাজ করে
- NULL হতে পারে না এবং ইউনিক হতে হবে  
- প্রতিটি টেবিলে শুধুমাত্র একটি প্রাইমারি কী থাকতে পারে  
- প্রাইমারি কী স্বয়ংক্রিয়ভাবে ইনডেক্স তৈরি করে, যা সার্চ পারফরম্যান্স বাড়ায়

  
**উদাহরণ:**
```sql
CREATE TABLE species (
  species_id SERIAL PRIMARY KEY,
  common_name VARCHAR(100)
);
````

এখানে `species_id` হল প্রাইমারি কী।

**ফরেন কী (Foreign Key):**
ফরেন কী এমন একটি কলাম, যা অন্য টেবিলের প্রাইমারি কী-এর সঙ্গে সম্পর্ক তৈরি করে। এটি মূলত দুই টেবিলের মধ্যে লিংক স্থাপন করে।

**বৈশিষ্ট্যগুলি:**

- একটি টেবিলের কলাম বা কলামের গ্রুপ যা অন্য টেবিলের প্রাইমারি কী কে রেফারেন্স করে  
- রিলেশনাল ডাটাবেসে টেবিলের মধ্যে সম্পর্ক স্থাপন করে  
- রেফারেন্সিয়াল ইন্টিগ্রিটি নিশ্চিত করে  
- ফরেন কী ব্যবহার করে কনস্ট্রেইন্ট সেট করা যায় যাতে অবৈধ রেফারেন্স ব্লক করা যায়  
- একাধিক ফরেন কী একটি টেবিলে থাকতে পারে, যা বিভিন্ন টেবিলের সঙ্গে সংযোগ স্থাপন করে

  
**উদাহরণ:**

```sql
CREATE TABLE sightings (
  sighting_id SERIAL PRIMARY KEY,
  species_id INT REFERENCES species(species_id)
);
```

এখানে `species_id` হল ফরেন কী, যা `species` টেবিলের সঙ্গে যুক্ত।

---

# 5. Explain the purpose of the WHERE clause in a SELECT statement.

WHERE ক্লজ ব্যবহার করে ডেটাবেজ থেকে নির্দিষ্ট শর্ত পূরণ করা রো/তথ্যগুলো বেছে নেওয়া যায়। এটি মূলত ফিল্টারিংয়ের কাজ করে।

**মূল কাজগুলো:**

* শর্ত অনুযায়ী রো বাছাই করে
* একাধিক শর্ত একসাথে (AND, OR) ব্যবহার করা যায়
* কম্প্যারিজন অপারেটর (=, <>, >, <, >=, <=) ব্যবহার করতে পারে
* LIKE অপারেটর দিয়ে প্যাটার্ন ম্যাচিং সাপোর্ট করে
* IN, BETWEEN, IS NULL এর মতো অপারেটর সাপোর্ট করে



**উদাহরণ:**

```sql
SELECT * FROM sightings WHERE location LIKE '%Hill%';
```

এখানে `location` কলামে যেসব মানের মধ্যে "Hill" আছে, কেবল সেগুলোই রিটার্ন হবে।

---

# 6. What are the LIMIT and OFFSET clauses used for?

LIMIT এবং OFFSET হলো PostgreSQL-এ ডেটা রিড করার সময় ব্যবহার করা দুটি ক্লজ, যা মূলত রেজাল্ট কনট্রোল করার জন্য ব্যবহৃত হয়।

**LIMIT:**
LIMIT ক্লজ ব্যবহার করে আমরা নির্ধারণ করতে পারি, কতোটি রো (row) বা ডেটা আমরা দেখতে চাই। এটি রেজাল্টের সংখ্যাকে সীমিত করে।

**OFFSET:**
OFFSET ক্লজ ব্যবহার করে আমরা বলতে পারি, রেজাল্টের কতটি রো স্কিপ করে তারপর থেকে ডেটা দেখাবে।

**ব্যবহারিক উদাহরণ:**

```sql
SELECT * FROM sightings ORDER BY sighting_time DESC
LIMIT 10 OFFSET 20;
```

**ব্যাখ্যা:**

* `LIMIT 10` → সর্বোচ্চ ১০টি রো দেখাবে
* `OFFSET 20` → প্রথম ২০টি রো বাদ দিয়ে এরপরের ১০টি রো দেখাবে

**কেন ব্যবহার করব:**

* Pagination বা ডেটাকে পেজ আকারে দেখানোর জন্য (যেমন: ওয়েবসাইটে “Next Page”)
* বড় ডেটাবেজে লোড কমানোর জন্য
* নির্দিষ্ট অংশের ডেটা দেখতে চাইলে

---

# 7. How can you modify data using UPDATE statements?

UPDATE স্টেটমেন্ট ব্যবহার করে আমরা একটি টেবিলের এক বা একাধিক রো-এর নির্দিষ্ট কলামের মান পরিবর্তন করতে পারি।

**UPDATE এর মূল গঠন:**

```sql
UPDATE table_name
SET column1 = new_value1, column2 = new_value2
WHERE condition;
```

**উদাহরণ:**
 আমরা `species` টেবিলে একটি প্রজাতির `conservation_status` আপডেট করতে চাই:

```sql
UPDATE species
SET conservation_status = 'Endangered'
WHERE species_id = 5;
```

**ব্যাখ্যা:**

* `species` হলো টেবিলের নাম
* আমরা `conservation_status` কলামের মান পরিবর্তন করছি
* `WHERE` ক্লজ দিয়ে ঠিক করেছি কোন রো (species\_id = 5) আপডেট হবে

**সতর্কতা:**

* `WHERE` ক্লজ না দিলে টেবিলের সব রো আপডেট হয়ে যাবে
* আপডেট করার আগে ভালোভাবে যাচাই করা উচিত, যাতে ভুলভাবে তথ্য পরিবর্তন না হয়

---

# 10. How can you calculate aggregate functions like COUNT(), SUM(), and AVG() in PostgreSQL?

PostgreSQL-এ Aggregate Function ব্যবহার করে ডেটার উপর গণনা (calculation) করা যায়। এই ফাংশনগুলো সাধারণত অনেক রেকর্ডের উপর কাজ করে এবং একটি একক রেজাল্ট রিটার্ন করে।

**1. COUNT() – মোট কতটি রেকর্ড আছে তা গণনা করে**

```sql
SELECT COUNT(*) FROM sightings;
```

এখানে দেখা যাবে `sightings` টেবিলে মোট কতটি রো আছে।

**2. SUM() – নির্দিষ্ট সংখ্যার মোট যোগফল বের করে**

```sql
SELECT SUM(species_id) FROM sightings;
```

এখানে `sightings` টেবিলের সব `species_id` এর যোগফল দেখাবে (যদিও সাধারণত সংখ্যাগত মানে বেশি কাজ হয়, যেমন price বা quantity)।

**3. AVG() – গড় মান বের করে**

```sql
SELECT AVG(ranger_id) FROM sightings;
```

এটি দেখাবে `ranger_id` কলামের গড় মান (তবে বাস্তবে এটি সংখ্যা ভিত্তিক মানে বেশি ব্যবহার হয়, যেমন rating, temperature ইত্যাদি)।

**গ্রুপ করে ব্যবহার :**

```sql
SELECT species_id, COUNT(*) 
FROM sightings 
GROUP BY species_id;
```

এখানে প্রতিটি `species_id` এর জন্য কতবার দেখা গেছে তা দেখাবে।

---

